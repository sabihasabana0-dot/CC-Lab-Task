int -> INT
findMax -> FUNCTION_FINDMAX
( -> LPAREN
int -> INT
arr -> IDENT_ARR
[ -> LSQUARE
] -> RSQUARE
, -> COMMA
int -> INT
size -> IDENT_SIZE
) -> RPAREN
{ -> LBRACE
int -> INT
max -> IDENT_MAX
= -> ASSIGN
arr -> IDENT_ARR
[ -> LSQUARE
0 -> NUMBER
] -> RSQUARE
; -> SEMICOLON
for -> FOR
( -> LPAREN
int -> INT
i -> IDENT_I
= -> ASSIGN
1 -> NUMBER
; -> SEMICOLON
i -> IDENT_I
< -> LESS_THAN
size -> IDENT_SIZE
; -> SEMICOLON
i -> IDENT_I
++) -> RPAREN
{ -> LBRACE
if -> IF
( -> LPAREN
arr -> IDENT_ARR
[ -> LSQUARE
i -> IDENT_I
] -> RSQUARE
> -> GREATER_THAN
max -> IDENT_MAX
) -> RPAREN
max -> IDENT_MAX
= -> ASSIGN
arr -> IDENT_ARR
[ -> LSQUARE
i -> IDENT_I
] -> RSQUARE
; -> SEMICOLON
} -> RBRACE
return -> RETURN
max -> IDENT_MAX
; -> SEMICOLON
} -> RBRACE
int -> INT
main -> FUNCTION_MAIN
( -> LPAREN
) -> RPAREN
{ -> LBRACE
int -> INT
nums -> IDENT_NUMS
[ -> LSQUARE
] -> RSQUARE
= -> ASSIGN
{ -> LBRACE
12 -> NUMBER
, -> COMMA
56 -> NUMBER
, -> COMMA
34 -> NUMBER
, -> COMMA
89 -> NUMBER
, -> COMMA
23 -> NUMBER
} -> RBRACE
; -> SEMICOLON
int -> INT
maxValue -> IDENT_MAXVALUE
= -> ASSIGN
findMax -> FUNCTION_FINDMAX
( -> LPAREN
nums -> IDENT_NUMS
, -> COMMA
5 -> NUMBER
) -> RPAREN
; -> SEMICOLON
printf -> FUNCTION_PRINTF
( -> LPAREN
"Max = %d" -> STRING_LITERAL
, -> COMMA
maxValue -> IDENT_MAXVALUE
) -> RPAREN
; -> SEMICOLON
return -> RETURN
0 -> NUMBER
; -> SEMICOLON
} -> RBRACE
